

206. 反转链表: 1234=>4321

    ```C++
    while(head) {
        // 备份当前的下一个节点
        ListNode* tmp = head->next;
        // 使当前节点链接新头newHead
        head->next = newHead;
        // 把当前节点放到新头中
        newHead = head;
        // 移动当前节点
        head = tmp;
    }
    ```

207. 课程表: 判断有向图中是否有环?

    把所有入度为0的阶段放进队列, 因为不会冲突
    遍历队列, 找当前节点的相邻节点, 如果相邻节点的入度-1==0, 入队
    遍历完成, 判断课程总数是否减到0

208. 实现前缀树: 

    插入: 从根节点的子节点开始和word的字符匹配, 直到树中没有匹配的, 然后开辟新节点, 放置剩下的字符
    搜索: 从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回false，如果匹配到了最后一个字符，那我们只需判断node->isEnd即可
    前缀匹配: 和 search 操作类似，只是不需要判断最后一个字符结点的isEnd，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的

213. 打家劫舍II: 房屋围成一圈, 相邻的不能投

    房屋1和最后一间房子相邻, 不能同时被偷, 那么, 就有三种情况:
    1. 房屋1被偷, 最后一个没有被偷
    2. 最后一个被偷, 房屋1没有被偷
    3. 都没有被偷
    这三种情况将整个数组拆分成三个部分数组, 区间分别是[0, size-2], [1, size-1], [1, size-2], 分别求出它们的最大值(对于每一部分数组, 还是题目一的思路)

214. 最短回文串: 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串


225. 队列实现栈: 

    关键在于, 向队列左端放入元素之后, 要把右端的都移除放到左端, 保证栈顶(队列右端)是最近的

232. 栈实现队列: in栈和out栈

    总体思路就是, 压入的时候把元素放到in栈; 查询的时候操作out栈(从in栈依次放入的)
    插入: 直接压入in栈
    移除: 如果outStack中没有元素，就先把inStack中的元素依次弹出压入outStack; 如果outStack中已经有元素了,就直接获取outStack的栈顶元素
    获取栈顶: 如果outStack中没有元素，就先把inStack中的元素依次弹出压入outStack; outStack中已经有元素了,就直接获取outStack的栈顶元素

234. 回文链表: 反转前半部分链表, 然后和后半部分比较, 注意奇偶问题

    ```C++
    // 遍历的时候反转前半部分
    while(fast && fast->next){
        p = slow;
        slow = slow->next;    //快慢遍历
        fast = fast->next->next;
        //翻转
        p->next = pre;  
        pre = p;
    }
    //奇数个节点时跳过中间节点  
    if(fast)  
        slow = slow->next;
    // 前半部分和后半部分比较
    while(p){       
        if(p->val != slow->val)
            return 0;
        p = p->next;
        slow = slow->next;
    }
    ```

236. 二叉树的最近公共祖先: 

    两种情况: pq在祖先的两侧, 那么当前节点就是所求; pq在一侧, 那么靠上边的那个就是所求
    ```C++
    // basecase 
    if (!root || root == p || root == q) return root;
    // 找左半部分 
    TreeNode *left = lowestCommonAncestor(root->left, p, q);
    // 找右半部分
    TreeNode *right = lowestCommonAncestor(root->right, p, q);
    // p q在两侧, 当前就是所求
    if (left && right) return root;
    // p q在一侧, 上边的那个是所求
    return left ? left : right;
    ```