

101. L

102. L

103. L

104. 二叉树的最大深度: 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数

     层次遍历, 每遍历完一层, count++

105. 从前序遍历和中序遍历构建二叉树

     ```C++
     TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
         TreeNode* root = helper(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
         return root;
     }
     
     TreeNode* helper(vector<int> pre,int startPre,int endPre,vector<int> vin,int startVin,int endVin) {
         // 边界判断
         if(startPre > endPre || startVin > endVin)
         	return NULL;
         // 1.初始化根节点: 永远是前序遍历的首元素    
         TreeNode* root = new TreeNode(pre[startPre]);
         // 2.遍历中序遍历数组, 区分左右子树    
         for(int i = startVin; i <= endVin; i++)
             if(vin[i] == pre[startPre]) {
                 // 2.1左子树递归创建
                 // 关键在于左右子树的索引范围界定
                 root->left = helper(pre,startPre+1,startPre+i-startVin,vin,startVin,i-1);
                 // 2.2右子树递归创建
                 root->right= helper(pre,i-startVin+startPre+1,endPre,vin,i+1,endVin);
                 break;
         }
     
         return root;
     }
     ```

106. L

107. L

108. L

109. L

110. L

111. L

112. L

113. L

114. 二叉树展开为链表: 前序遍历顺序

     ```C++
     void flatten(TreeNode* root) {
     while (root != nullptr) {
         if (root->left != nullptr) {
                 // 如果左子树不为空, 那么就先找到左子树的最右节点
                 auto most_right = root->left; 
                 // 找最右节点
                 while (most_right->right != nullptr) most_right = most_right->right; 
                 // 然后将跟的右孩子放到最右节点的右子树上
                 most_right->right = root->right;
                 // 这时候跟的右孩子可以释放, 令左孩子放到右孩子上 
                 root->right = root->left;
                 // 将左孩子置为空 
                 root->left = nullptr; 
          }
          // 继续下一个节点
          root = root->right; 
         }
         return;
     }
     ```

115. L

116. L

117. L

118. L

119. L

120. L

121. 买卖股票的最佳时机: 最多只允许完成一笔交易（即买入和卖出一支股票一次）

     ```c++
     int n = prices.length;
     if (n == 0) return 0;
     // dp表示当前i天, 持有(1)或不持有(0)的最大收益
     int[][] dp = new int[n][2];
     for (int i = 0; i < n; i++) {
         // 初始化
         if (i == 0) {
             // 第一天不买
             dp[i][0] = 0;
             // 第一天买了
             dp[i][1] = -prices[i];
             continue;
     	}
         // 当前没有股票 {前一天也没有, 前一天卖了}
         dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
         // 当前有股票 {前一天就有, 前一天买了}
         dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
     }
     // 最大一定是不持有
     return dp[n-1][0];
     ```

122. 买卖股票问题II: 可以尽可能地完成更多的交易（多次买卖一支股票）

     解法同上题; 因为交易次数可以无限大, 所以他对状态的影响忽略

123. 买卖股票问题III: 限制完成两次交易

     ```c++
     if (prices.length == 0) {
     	return 0;
     }
     long[][][] dp = new long[prices.length][3][2];
     dp[0][1][0] = Integer.MIN_VALUE;
     dp[0][1][1] = -prices[0];
     dp[0][2][0] = Integer.MIN_VALUE;
     dp[0][2][1] = Integer.MIN_VALUE;
     for (int i = 1; i < prices.length; i++) {
         dp[i][1][0] =
         Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);
         dp[i][1][1] =
         Math.max(dp[i-1][1][1], -prices[i]);
         dp[i][2][0] =
         Math.max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]);
         dp[i][2][1] =
         Math.max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]);
     }
     int res = (int) Math.max(dp[prices.length - 1][2][0], 	
     	dp[prices.length - 1][1][0]);
     return res < 0 ? 0 : res;
     ```

124. 二叉树中最大路径和: 从树中任意节点出发，达到任意节点的序列

     ```C++
     int dfs(TreeNode* root) {
         // basecase
         if (root == NULL) return 0;
         //计算左边分支最大值, 负数不如0
         int leftMax = max(0, dfs(root->left));
         //计算右边分支最大值
         int rightMax = max(0, dfs(root->right));
         //与历史最大值做比较
         maxs = max(maxs, root->val + leftMax + rightMax);
         //+root计算总和
         return root->val + max(leftMax, rightMax);
     }
     ```

125. 验证回文串:忽略大小写和标点

     两端向中间挤, `while(start < end) `更新指针

126. 单词接龙II

127. 单词接龙

128. L

129. L

130. 被围绕的区域: 找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

131. 分割回文串: 将 *s* 分割成一些子串，使每个子串都是回文串

     ```C++
     	// 回溯
         void backtrack(string s,vector<string>&path,int pre){
             //判断结束条件
             if(pre >= s.size()){     
                 res.push_back(path);
                 return;
             }
             for(int i=pre; i<s.size(); i++){       
                 // 判断是否为回文, 剪枝     
                 if(! checks(s,pre,i)) continue;
                 // 注意: substr(pos,n)
                 path.push_back(s.substr(pre,i+1-pre));
                 backtrack(s,path,i+1);
                 path.pop_back();    //还原
             }
         }
     
         // 判断是否是回文串
         bool checks(string s, int le, int ri) {
             // 严格小于即可
             while (le < ri) {
                 if (s[le] != s[ri]) {
                     return false;
                 }
                 le++;
                 ri--;
             }
             return true;
         }
     ```

132. L

133. ;

134. 加油站: 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

     你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

     如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

     ```c++
     int n = gas.size();
     // 邮箱总量
     int total_tank = 0;
     // 当前量
     int curr_tank = 0;
     // 起始加油站
     int starting_station = 0;
     // 遍历每一个油站
     for (int i = 0; i < n; ++i) {
         // 总量 = 原总量 + 油站有的 - 到i消耗的
         total_tank += gas[i] - cost[i];
         // 当前量 = 原当前 + 油站有的 - 到i消耗的
         curr_tank += gas[i] - cost[i];
         // 到不了: 当前量<0
         if (curr_tank < 0) {
             // 就将下一个作为起始加油站
             starting_station = i + 1;
             // 当前量置为0
             curr_tank = 0;
         }
     }
     // 总量不空就能到
     return total_tank >= 0 ? starting_station : -1;
     ```

135. 分发糖果: 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

     你需要按照以下要求，帮助老师给这些孩子分发糖果：

     每个孩子至少分配到 1 个糖果。
     相邻的孩子中，评分高的孩子必须获得更多的糖果。
     那么这样下来，老师至少需要准备多少颗糖果呢？

     ```C++
     int candy(vector<int>& ratings) {
         int n = ratings.size();
         // 两次遍历, 记录两次值, 取最大的累加
         vector<int> left(n,1);
         vector<int> right(n,1);
         // 从前往后
         for(int i = 1; i < n; i++)
             // 如果当前的分数大于前一个, 就把当前的加一
             if(ratings[i] > ratings[i - 1]) 
             	left[i] = left[i - 1] + 1;
         // 记录最后一个孩子的糖果数
         int count = left[n - 1];
         // 从后往前, 从倒数第二个孩子开始
         for(int i = n - 2; i >= 0; i--) {
             // 如果当前的分数大于后一个, 就把当前的加一
             if(ratings[i] > ratings[i + 1]) right[i] = right[i + 1] + 1;
             // 取最大的累加
             count += max(left[i], right[i]);
         }
         return count;
     }
     ```

136. 只出现一次的数字: 其他都出现两次

     ```C++
     for (int i = 1; i < nums.size(); i++) {
         // 相同为0, 不同为1
         ans = ans ^ nums[i];
     }
     ```

137. 只出现一次的数字: 其他都出现三次

     ```C++
     // 遍历int的32位
     // 相同数字的同一位0或1出现次数一定是3的整数倍
     for(int i = 0; i < 32; ++i){
         int sum = 0;
         // 遍历每个数字的每一位
         for(int j = 0;j < nums.size();++j){
             // 统计每一位出现的次数
             sum += (nums[j] >> i) & 1;
         }
         // 求余得出目标数字在该位上的值
         // 进而构求出原数字
         res ^= (sum % 3) << i;
     }
     ```

138. L

139. L

140. L

141. 环形链表: 

     快慢指针, 构建速度差, 有环必定相遇

142. L

143. L

144. L

145. L

146. LRU缓存机制: 有容量, 最长时间没有访问的踢出去

    带有key~value的双向链表(双向是为了方便定位到尾节点, 也就是最久没访问的那个节点)

147. L

148. 排序链表: 

    每次双指针找到中间点断开, 递归地拆分左右两边, 直到子链表中只有一个节点(有序)
    合并两个有序链表

149. L

150. L
