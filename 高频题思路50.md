# leetcode面试高频题思路记录

1.  两数之和: 返回数组中和为target的下标

   建立 值~下标的map, 遍历数组, 找到值, 进而返回下标

2. 两数相加: 逆序的链表数值相加, 返回逆序的新链表

   因为逆序, 直接就是从低位相加; 模拟进位,

   `carry = digit / 10`; 

   `cur->next = new ListNode(digit % 10);`

3. 无重复最长字串:

   滑动窗口, --------------------------------------------------------------

5. 最长回文字串: 找字符串中最长的回文字串

   找回文串, "中心扩散法"; 

   遍历所有字符, 从该字符开始找回文串(注意奇偶长度)

   从当前字符向两端扩散, 不等就break, 等了就继续扩大

   维持一个maxLen并返回

6. L

7. 整数反转: 反转32位有符号整数(123->321)

   ```java
   while(x!=0) {
   	int pop = x % 10;
       x /= 10;
       // 处理溢出
       if (result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE / 10 && pop > 7)) 
               return 0;
       if (result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE / 10 && pop < -8)) 
               return 0;
       result = result * 10 + pop;
   }
   ```

8. L

9. 回文数: 正序倒序都一样

   ```C++
   // 反转一半数字, 判断是否相等
   int ans = 0;
   // 关键在于循环的判断
   while(x > ans) {
       // 构建数字ans
       ans = ans*10 + x%10;
       // 消减x的数位
       x /= 10;
   }
   // 偶数长度 || 奇数长度
   return x==ans || x==(ans/10);
   ```

10. xxx----------------------------------------

11. 

12. 

13. 

14. 最长公共前缀: 一组单词中的最长公共前缀

    初始化前缀是首个单词; 遍历每个单词, 和前缀比较; 

    找到开始一样的地方, 记住下标, 更新前缀

15. 三数之和: 返回数组中和是target的三个元素, 不能重复

    递归减规模; 

    两数之和: 排序: 双指针从两头开始, 组成的sum大了low++, 小了就hi--, 相等就加入结果集(注意判重: 相邻元素相等就++指针)

    三数之和: 排序; 对于每一个元素i, 转换成`target=target-nums[i]`的二数之和问题

16. L

17. 电话号码组合: 给数字, 返回可能的号码的字母组合

    ```C++
    vector<string> ans;
    string temp;
    // 错位数组
    string dic[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return ans;
        temp.resize(digits.size());
        dfs(digits, 0);
        return ans;
    }
    // 回溯
    void dfs(string& digits, int k) {
        // 返回条件: 构建的字符长==数字长
        if (k == digits.size()) {
            ans.push_back(temp);
            return;
        }
        // 获得下标
        int t = digits[k] - '0';
        // 遍历下标对应的各个字符
        for (int i = 0; i < dic[t].size(); i++) {
            // 选择: 增加temp长
            temp[k] = dic[t][i];
            // 递归, 处理下一个下边
            dfs(digits, k + 1);
        }
    }
    ```

18. 四数之和:返回数组中和为target的四个数, 不能重复复

    二数之和: 排序: 双指针从两头开始, 组成的sum大了low++, 小了就hi--, 相等就加入结果集(注意判重: 相邻元素相等就++指针)

    三数之和: 排序; 对于每一个元素i, 转换成`target=target-nums[i]`的二数之和问题

19. 删除链表倒数第N个节点: 

    快慢指针, fast到头, slow即是目标节点

20. 有效的括号: 判断括号字符串是否有效

    借助栈先入后出, 遇到左括号, 栈中放入它的右括号; 

    遇到右括号, 在栈顶对比, 如果不一样, 就false; 

    如果能出战完, 就是true

21. 合并两有序链表: 

    串联指针, 遍历两链表, 比较值大小, 串联, 移动小的指针和串联指针

    某个链表为空, 推出循环, 一次性穿起来剩下的那部分

22. 括号生成: 生成N对合法的括号组合

    ```C++
    vector<string> res;
    void helper(string track, int left, int right, int n){
        // 要生成n对括号, 长度就是n*2
        if(track.size() == n*2) { 
            res.push_back(track);
            return;
        }
        // 左括号数量不够
        if(left < n) { 
        	helper(track+"(", left+1, right, n);
        }
        // 右括号不等于左括号，且保证右括号在左前
        if(right < left) { 
        	helper(track+")", left, right+1, n);
        }
    }
    ```

23. 合并K个排序链表: 给一个链表数组, 返回合并后的链表

    ```C++
    // 二分法(归并排序)
    ListNode* merge(vector<ListNode*>& lists, int start, int end){
        // 出口
        if(start == end) return lists[start];
        int mid = (start + end) / 2;
        // 左半部分
        ListNode* l1 = merge(lists, start, mid);
        // 右半部分
        ListNode* l2 = merge(lists, mid+1, end);
        // 合并两个链表
        return merge2(l1, l2);
    }
    ```

24. 两两交换链表节点: 1234=>2143

    ```C++
    while (temp->next != NULL && temp->next->next != NULL){ 
        ListNode* pre = temp->next; 
        ListNode* be = temp->next->next;
        // 1.将后边节点放在前
        temp->next = be; 
        // 2.维系和后续节点的联系
        pre->next = be->next; 
        // 3.将原先在前的节点放在后
        be->next = pre; // 完成交换
        // 4.移动串联指针, 预备下一组交换
        temp = pre; 
    } 
    ```

25. K个一组反转链表: K=2时, 12345 => 21435

    ```C++
    	// 翻转一个子链表，并且返回新的头与尾
        pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
            ListNode* prev = tail->next;
            ListNode* p = head;
            while (prev != tail) {
                ListNode* nex = p->next;
                p->next = prev;
                prev = p;
                p = nex;
            }
            return {tail, head};
        }
    
        ListNode* reverseKGroup(ListNode* head, int k) {
            ListNode* hair = new ListNode(0);
            hair->next = head;
            ListNode* pre = hair;
            // K个一组对链表分组
            while (head) {
                ListNode* tail = pre;
                // 对于每组, 查看剩余部分长度是否大于等于 k
                for (int i = 0; i < k; ++i) {
                    tail = tail->next;
                    if (!tail) {
                        return hair->next;
                    }
                } 
                ListNode* nex = tail->next;
                // 传入每组链表的头和尾, 获取返回后的头和尾
                pair<ListNode*, ListNode*> result = myReverse(head, tail);
                head = result.first;
                tail = result.second;
                // 把子链表重新接回原链表
                pre->next = head;
                tail->next = nex;
                pre = tail;
                head = tail->next;
            }
            return hair->next;
        }
    ```

26. L

27. L

28. L

29. L

30. L

31. L

32. 最长有效括号: 找最长的有效括的字串

    设DP[i]表示以下标为 i 的字符结尾的最长有效子字符串的长度(老套路了)

    ```C++
    // 结尾是左括号肯定不行
    if s[i] == '(' :
        dp[i] = 0
    if s[i] == ')' :
    	// 结尾的两个成型, 就取决于i-2
        if s[i - 1] == '(' :
            dp[i] = dp[i - 2] + 2 
    	// 结尾两个是右括号, 找对应下标是否是左括号
        if s[i - 1] == ')' and s[i - dp[i - 1] - 1] == '(' :
            dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 
    
    ```

33. 搜索旋转排序数组: 

    ```C++
    // 二分法的思想
    while (lo <= hi) {
        mid = lo + (hi - lo) / 2;
        // 找到了
        if (nums[mid] == target) {
        	return mid;
        }
        // 如果nums[mid] > nums[lo], 则左半段有序 
        if (nums[mid] >= nums[lo]) {
            // target在左边的有序段
            if (target >= nums[lo] && target < nums[mid]) {
                // 移动高位指针
                hi = mid - 1;
            } else {
            	lo = mid + 1;
            }
        } 
        // mid之后的右半段有序
        else {
            if (target > nums[mid] && target <= nums[hi]) {
            	lo = mid + 1;
            } else {
            	hi = mid - 1;
            }
        }
    }
    ```

34. 排序数组找目标元素的第一个和最后一个位置

    分别找左边界和右边界

    ```java
    // 找左边区间边界
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            // 中间点分割
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界, 挤出目标索引
                right = mid - 1;
            }
        }
        // 检查出界情况
        if (left >= nums.length || nums[left] != target)
        return -1;
        return left;
    }
    ```

35. L

36. L

37. L

38. L

39. 组合总和: 找数组中和是target的组合

    一定先要排序

    ```C++
    // 回溯
    void DFS(int start, int target) {
        // target减为0
        if (target == 0) {
            res.push_back(path);
            return;
        }
        // 从start遍历每个元素
        for (int i = start; i < candidates.size(); i++) {
            // 剪枝, 遇到比target大的
            if (target - candidates[i] < 0) continue;
            path.push_back(candidates[i]);
            // 递归: target减小规模
            DFS(i, target - candidates[i]);
            path.pop_back();
        }
    }
    ```

40. 组合综合II: 找数组中和是target的组合, 不能重复

    一定先要排序, 剪枝时判断相邻元素是否相等

41. L

42. 接雨水: 数组元素表示柱子高, 求可以接的雨水和

    ```C++
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
        int n = height.size();
        // 双指针
        int left = 0, right = n - 1;
        int ans = 0;
        // l_max是[0,left]中最高的柱子
        int l_max = height[0];
        // r_max是[right,end]中最高的柱子
        int r_max = height[n - 1];
        // 遍历每个柱子, 计算容量
        while (left <= right) {
            l_max = max(l_max, height[left]);
            r_max = max(r_max, height[right]);
            // 容量以短板为准
            if (l_max < r_max) {
                // 累加容量
                ans += l_max - height[left];
                left++; 
            } else {
                ans += r_max - height[right];
                right--;
            }
        }
        return ans;
    }
    ```

43. 字符串相乘: 两个字符串非负整数, 算乘积

    ```C++
    // 双指针遍历两数的每一位, 计算乘积, 叠加到res中
    string multiply(string num1, string num2) {
        int m = num1.size(), n = num2.size();
        // 结果最多为 m + n 位数
        vector<int> res(m + n, 0);
        // 从个位数开始逐位相乘
        for (int i = m - 1; i >= 0; i--)
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1[i]-'0') * (num2[j]-'0');
                // 乘积在 res 对应的索引位置, 至多占用两位
                int p1 = i + j, p2 = i + j + 1;
                // 叠加到 res 上
                int sum = mul + res[p2];
                // 个位
                res[p2] = sum % 10;
                // 进位
                res[p1] += sum / 10;	
            }
        // 结果前缀可能存的 0（未使用的位）
        int i = 0;
        while (i < res.size() && res[i] == 0)
        	i++;
        // 将计算结果转化成字符串
        string str;
        for (; i < res.size(); i++)
            str.push_back('0' + res[i]);
        return str.size() == 0 ? "0" : str;
    }
    ```

44. L

45. L

46. 全排列: 无重复数字的数组, 返回可能的全排列

    ```C++
    void backtrack(vector<int>& track, vector<int>& nums) {
        // 判断
        if (track.size() == nums.size()) {
            res.push_back(track);
            return;
        }
        // 遍历
        for (int i = 0; i < nums.size(); i ++) {
            // 剪枝,取消重复
            // 如果记录的路径中,已经含有了当前元素, 就跳过本次
            if (find(track.begin(), track.end(),nums[i]) != track.end()) continue;
            // 放入选择
            track.push_back(nums[i]);
            // 递归
            backtrack(track, nums);
            // 撤销 选择
            track.pop_back();
        }
    }
    ```

47. 全排列II: 有重复数字的数字, 返回所有可能的全排列

    先排序, 剪枝的时候判断相邻元素是否相等

48. 旋转图像: 原地把矩阵顺势转90°

    ```C++
    // 转置矩阵: 对角线交换, A12-A21
    for(int i = 0; i < len; i ++) {
        for (int j = i; j < len; j ++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    
    // 对于每一行进行左右反转
    for(int i = 0; i < len; i++) {
        // 注意:行长度的奇偶情况
        for(int j = 0; j < len/2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][len-j-1];
            matrix[i][len-j-1] = temp;
        }
    }
    ```

49. L

50. POW快速幂

    ```C++
    double quickMul(double x, long long N) {
        if (N == 0) return 1.0;
        // 递归减N的规模
        double y = quickMul(x, N / 2);
        // 处理N的奇偶
        return N % 2 == 0 ? y * y : y * y * x;
    }
    
    double myPow(double x, int n) {
        long long N = n;
        // 处理指数的正负
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
    ```
