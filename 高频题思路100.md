51. N皇后: m*n棋盘放置皇后, 使四周不冲突

    关键在于剪枝函数的编写

    ```
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        // 检查列是否有皇后互相冲突
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q')
            return false;
        }
        // 检查右上方是否有皇后互相冲突
        for (int i = row - 1, j = col + 1; 
        	i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q')
                return false;
        }
        // 检查左上方是否有皇后互相冲突
        for (int i = row - 1, j = col - 1;
        	i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
            return false;
        }
        return true;
    }
    ```

52. L

53. 最大子序和: 返回拥有最大和的连续字数组

    ```C++
    // dp[i]表示以nums[i]结尾的子数组的最大和
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    // 维护max, 放dp中的最大值
    int maxs = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        // 两种选择, 择优选取最大的
        dp[i] = max(dp[i - 1] + nums[i], nums[i]);	
        if (maxs < dp[i]) {
        	maxs = dp[i];
        }
    }
    return maxs;
    ```

54. 螺旋矩阵: 顺时针螺旋打印二维矩阵

    ```C++
        // 移动到最右, 更新上边界
        // 移动到最底, 更新右边界...
        vector<int> spiralOrder(vector<vector<int>>& matrix) {
            vector <int> ans;
            if(matrix.empty()) return ans; 
            //赋值上下左右边界
            int u = 0; 
            int d = matrix.size() - 1;
            int l = 0;
            int r = matrix[0].size() - 1;
            while(true) {
                // 向右移动直到最右
                for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); 
                // 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
                if(++ u > d) break; 
                // 向下直到底部
                for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); 
                // 重新设定右边界
                if(-- r < l) break; 
                // 向左
                for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); 
                // 重新设定下边界
                if(-- d < u) break; 
                // 向上
                for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); 
                // 重新设定左边界
                if(++ l > r) break; 
            }
            return ans;
        }
    ```

55. 跳跃游戏: 判断从数组出位置, 能够跳到莫位置

    ```C++
    int flag = nums.size() - 1;
    // 从后往前遍历数组
    for(int i = nums.size() - 1; i >= 0; i --) {
        // 判断前面节点能否到达标志位
        if(nums[i] + i >= flag) {
            // 如果可以，就移动标志位
            flag = i;
        }
    }
    return flag == 0;
    ```

56. L

57. L

58. L

59. L

60. L

61. 旋转链表: 将链表每个节点向右移动 *k* 个位置; 12345=>45123(k=2)

    ```C++
    // 定义快慢指针
    ListNode *slow = head, *fast = head;
    int n = 0;
    // 求链表长
    for(auto p=head;p;p=p->next) n++;
    // 避免k大于链表长的情况
    k %= n;
    int distance = 0;
    while (fast->next) {
        // 快指针先走
        if (distance < k) {
        fast = fast->next;
        distance ++;
        }
        // 同步走
        else {
        fast = fast->next;
        slow = slow->next;
        }
    }
    // 循环结束, 两指针中间的就是需要旋转的
    fast->next = head;
    // 新的头也就是slow指针的后一个节点
    head = slow->next;
    slow->next = NULL;
    // 返回新的头
    return head;
    ```

62. 不同路径: m*n网格, 左上到右下的路径和

    ```C++
    // dp表示到达i+1,j+1的路径和
    vector< vector <int> > dp(m, vector<int> (n));
    // 初始化边界情况
    for (int i = 0; i < m; i ++) dp[i][0] = 1;
    for (int i = 0; i < n; i ++) dp[0][i] = 1;
    // 遍历每个格子
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            // 累加
            dp[i][j] = dp[i - 1][j] + dp[i][j -  1];
        }
    }
    return dp[m-1][n-1];
    ```

63. 不同路径:II: 网格中多了障碍物

    ```java
    // 和上题两处不同
    
    // 注意初始化不同
     for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
     	dp[i][0] = 1;
     }
     for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
     	dp[0][j] = 1;
     }
     ....
    // 注意dp累加前, 先判断
    if (obstacleGrid[i][j] == 0) {
    	dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
    ```

64. 最小路径和: mn网格, 从左上到右下的路径数字总和最小

    ```C++
    int rows = grid.size(), columns = grid[0].size();
    // dp表示i+1,j+1的数字总和
    auto dp = vector<vector<int> > (rows, vector<int>(columns));
    dp[0][0] = grid[0][0];
    // 初始化第一行
    for (int i = 1; i < rows; i++) {
    	dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    // 初始化第一列
    for (int j = 1; j < columns; j++) {
    	dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    // 遍历
    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < columns; j++) {
        	dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[rows - 1][columns - 1];
    ```

65. L

66. L

67. L

68. L

69. X的平方根: 

    ```C++
    // 二分法求平方根
    int l = 0, r = x, ans = -1;
    // 结束点
    while (l <= r) {
        // 分割点
        int mid = l + (r - l) / 2;
        // 小就往大猜
        if ((long long)mid * mid <= x) {
            ans = mid;
            l = mid + 1;
        }
        // 大往小
        else {
        	r = mid - 1;
        }
    }
    return ans;
    ```

70. L

71. L

72. L

73. L

74. L

75. L

76. 最小覆盖字串: 从字符串 S 里面找出：包含 T 所有字符的最小子串

    滑动窗口------------------------------------------

77. 组合: 返回 1 ... *n* 中所有可能的 *k* 个数的组合

    ```C++
    void dfs(int n, int k, int start, vector<int> &path) {
        if (path.size() == k) {
            ans.push_back(path);
            return;
        }
        // 回溯
        for (int i = start; i <= n; i++) {
            path.push_back(i);
            // 递归, 更新索引
            dfs(n,k,i+1,path);
            path.pop_back();
        }
    }
    ```

78. 子集: 给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）

    回溯法, 子集问题不用IF

    ```C++
    void backtrack(vector<int>& nums, int start, vector<int>& track) {
        res.push_back(track);
        // 保证开始索引不越界
        for (int i = start; i < nums.size(); i++) {
            // 做选择
            track.push_back(nums[i]);
            // 回溯, 递归: 更新开始索引
            backtrack(nums, i + 1, track);
            // 撤销选择, 移除track中的最后一个元素
            track.pop_back();
        }
    }
    ```

79. L

80. L

81. L

82. L

83. L

84. L

85. L

86. L

87. L

88. L

89. L

90. L

91. L

92. 翻转链表: 反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转-----------------------------------------------

93. L

94. L

95. L

96. L

97. L

98. L

99. 恢复二叉搜索树: 二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树

    ```
    	TreeNode* preNode = new TreeNode(INT_MIN);
        // 两个目标节点设为全局的
        TreeNode* firstNode = NULL, *secondNode = NULL;
        // 递归函数, 用于找到那两个节点
        void traverse(TreeNode* root) {
            if (root == NULL) return;
            // 中序遍历
            traverse(root->left);
            // 第一次降序
            if (firstNode == NULL && preNode->val > root->val)
                // 取前边的
                firstNode = preNode;
            // 第二次降序
            if (firstNode != NULL && preNode->val > root->val)
                // 取后边的
                secondNode = root;
            // 移动指针
            preNode = root;
            traverse(root->right);
        }
    
        // 在这里执行交换
        void recoverTree(TreeNode* root) {
            traverse(root);
            int tmp = firstNode->val;
            firstNode->val = secondNode->val;
            secondNode->val = tmp;
        }
    ```

100. L