

260. 只出现一次的数字III: 两个元素出现一次, 其余都出现两次

    思路: 把这两个元素分到两个数组中, 然后分别异或求得
        如何分?  因为a b两个数字不等, 所以a^b结果必至少有一位是1(因为0^1=, ab必至少有一位不同)
            找到a b异或结果中为1的任意一位, 通过该为位对数字分组
    ```C++
    // 异或结果
    int s = 0;
    for (int num : nums) {
        s ^= num;
    }
    // k是结果中为1的某一位
    int k = s & (-s);
    vector<int> rs(2,0);
    // 遍历数字,通过k分组
    for(int num : nums){
        if(num & k){
            //第二组
            rs[0] ^= num;
        }else{
            //第一组
            rs[1] ^= num;
        }
    }
    return rs;
    ```

292. NIM游戏: 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手

    关键在于: 总是给对手留下4块石头，那么对手一定会输;
        所以如果自己先手, 而石头数又是4的整数倍的话, 就一定会输

300. 最长上升子序列: 无序的整数数组，找到其中最长上升子序列的长度

    ```C++
    // 对于当前元素i
    for (int i = 0; i < n; i ++) {
        // 找到前遍序列中比元素i小的数
        for (int j = 0; j < i;j ++) {
            if (nums[j] < nums[i])
                // 要么续住之前的, 要么自己新开一个序列
                dp[i] = max(dp[i], dp[j]+1);
        }
    }
    ```

315. 计算右侧小于当前元素的个数:  counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量

322. 零钱兑换: 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数

337. 打家劫舍III: 这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警

    ```C++
    Map<TreeNode, Integer> memo = new HashMap<>();
    // 递归
    public int rob(TreeNode root) {
        if (root == null) return 0;
        // 如果备忘录中有, 直接返回
        if (memo.containsKey(root)) 
            return memo.get(root);
        // 抢，然后去下下家
        int do_it = root.val
            + (root.left == null ? 
                0 : rob(root.left.left) + rob(root.left.right))
            + (root.right == null ? 
                0 : rob(root.right.left) + rob(root.right.right));
        // 不抢，然后去下家
        int not_do = rob(root.left) + rob(root.right);
        // 两种选择中取最大的
        int res = Math.max(do_it, not_do);
        memo.put(root, res);
        return res;
    }
    ```

372. 超级次方: 计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出

    ```C++
    int base = 1337;
    // 计算 a 的 k 次方然后与 base 求模的结果
    int mypow(int a, int k) {
        // 对因子求模
        a %= base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            // 这里有乘法，是潜在的溢出点
            res *= a;
            // 对乘法结果求模
            res %= base;
        }
        return res;
    }
    // 递归
    int superPow(int a, vector<int>& b) {
        if (b.empty()) return 1;
        // 每次从数组中取末位
        int last = b.back();
        b.pop_back();
        // 计算末位部分
        int part1 = mypow(a, last);
        // 递归计算剩余部分
        int part2 = mypow(superPow(a, b), 10);
        // 两部分相乘得结果; 每次乘法都要求模
        return (part1 * part2) % base;
    }
    ```

376. 摆动序列: 连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列
        给定一个整数序列，返回作为摆动序列的最长子序列的长度

    ```C++
    // 特判
    if(nums.size()<2) return nums.size();
    // 状态机状态
    const int begin=0;
    const int up=1;
    const int down=2;
    // 初始状态
    int state = begin;
    int length = 1;
    // 状态的切换, 也就意味着length的重新开始
    for(int i = 1; i < nums.size(); i ++){
        switch(state){
            case begin:
                // 初始状态, 定义增降
                if(nums[i-1] < nums[i]){
                    state = up;
                    length ++;
                }
                else if(nums[i-1] > nums[i]){
                    state = down;
                    length ++;
                }
                break;
            case up:
                // 增 => 降
                if(nums[i-1] > nums[i]){
                    state = down;
                    length ++;
                }
                break;
            case down:
                // 降 => 增
                if(nums[i-1] < nums[i]){
                    state = up;
                    length ++;
                }
                break;
        }
    }
    return length;
    ```
402. 移除掉K位数字: 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小

409. 最长回文串: 给定一个包含大写字母和小写字母的字符串 找到通过这些字母构造成的最长的回文串

    ```C++
    // 缓存数组, 记录次数
    vector<int> arr(128);
    // 记录每种字符出现的次数
    for(char c : s) {
        arr[c]++;
    }
    int count = 0;
    // 出现偶数次, 一定可以拼成 
    for (int i = 0; i < arr.size(); i ++) {
        count += (arr[i] % 2);
    }
    // 都出现偶数次, 结果就是有多少种字符 
    // 出现有奇数次的, 就是偶数次的+1(奇数次的字符智能有一个放在中间)
    return count == 0 ? s.length() : (s.length() - count + 1);
    ```

416. 分割等和子集: 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等

    ```C++
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.size();
    // 容量是sum/2的背包
    sum = sum / 2;
    // 当前i个物品, 背包容量是sum的情况下, 能不能装入
    vector<vector<bool>> 
        dp(n + 1, vector<bool>(sum + 1, false));
    // base case
    for (int i = 0; i <= n; i++)
        dp[i][0] = true;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
                // 背包容量不足，不能装入第 i 个物品
                // 继承上一个状态
                dp[i][j] = dp[i - 1][j]; 
            } else {
                // 能装的下: 选择: 装入或不装入背包
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j-nums[i-1]];
            }
        }
    }
    return dp[n][sum];
    ```

438. 找到字符串中所有字母异位词

455. 分发饼干: 

    ```C++
    // 贪心
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // 排序
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        // 记录索引
        int res = 0, stry = 0;
        // 把饼干值大的优先发给胃口大的
        while (res < g.size() && stry < s.size()) {
            // 能满足, 就继续下一个饼干
            if (g[res] <= s[stry])
                res ++;
            // 不管能不能满足, 都继续下一个孩子
            stry ++;
        }
        return res;
    }
    ```