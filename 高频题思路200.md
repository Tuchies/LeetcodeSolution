
151. L

152. L

153. L

154. L

155. L

156. L

157. L

158. L

159. L

160. 相交链表: 找到两个单链表相交的起始节点

    ```C++
    if (headA == NULL || headB == NULL)
            return (ListNode*) NULL;
    ListNode* pa = headA;
    ListNode* pb = headB;
    // 当pa==pb时, 就是那第一个焦点
    while (pa != pb) {
        // pa跑完了在pb跑
        if (pa!=NULL) pa = pa->next;
        else pa = headB;
        // pb跑完了在pa跑
        if (pb!=NULL) pb = pb->next;
        else pb = headA;
    }
    // 相遇了就返回
    return pa;
    ```

161. L

191. 位1的个数: 一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）

    ```C++
    int count = 0;
    while(n > 0) {
        // 每次减少一位
        n &= (n - 1);
        count ++;
    }
    return count;
    ```
198. 打家劫舍: 不能投连续的房子, 求最大利润

    ```C++
    int N = nums.size();
    // dp表示当前i个房子能获取的最多
    vector<int> dp(N+1, 0);
    // 无意义
    dp[0] = 0;
    // 当前一个放子获取nums[0]
    dp[1] = nums[0];
    for (int k = 2; k <= N; k++) {
        // 偷前一个这个不偷 || 偷前前一个, 和这个
        dp[k] = max(dp[k-1], nums[k-1] + dp[k-2]);
    }
    return dp[N];
    ```

199. 二叉树的右视图: 想象自己从二叉树右侧看到的节点

    层次遍历: 将当前层的最后一个节点放入结果(`if size-1 == i`)

200. 岛屿数量: 网格中的岛屿数量

    DFS深度遍历每个 `grid[i][j]==1`的节点
    相邻节点: 上下左右
    basecase: 到达边界; 不是1则直接返回