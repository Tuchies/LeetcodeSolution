# leetcode面试高频题思路记录

1.  两数之和: 返回数组中和为target的下标

   建立 值~下标的map, 遍历数组, 找到值, 进而返回下标

2. 两数相加: 逆序的链表数值相加, 返回逆序的新链表

   因为逆序, 直接就是从低位相加; 模拟进位,

   `carry = digit / 10`; 

   `cur-next = new ListNode(digit % 10);`

3. 无重复最长字串:

   滑动窗口, --------------------------------------------------------------

5. 最长回文字串: 找字符串中最长的回文字串

   找回文串, "中心扩散法"; 

   遍历所有字符, 从该字符开始找回文串(注意奇偶长度)

   从当前字符向两端扩散, 不等就break, 等了就继续扩大

   维持一个maxLen并返回

6. L

7. 整数反转: 反转32位有符号整数(123->321)

   ```java
   while(x!=0) {
   	int pop = x % 10;
       x /= 10;
       // 处理溢出
       if (result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE / 10 && pop > 7)) 
               return 0;
           if (result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE / 10 && pop < -8)) 
               return 0;
       result = result * 10 + pop;
   }
   ```

8. L

9. 回文数: 正序倒序都一样

   ```C++
   // 反转一半数字, 判断是否相等
   int ans = 0;
   // 关键在于循环的判断
   while(x > ans) {
       // 构建数字ans
       ans = ans*10 + x%10;
       // 消减x的数位
       x /= 10;
   }
   // 偶数长度 || 奇数长度
   return x==ans || x==(ans/10);
   ```

10. xxx----------------------------------------

11. 

12. 

13. 

14. 最长公共前缀: 一组单词中的最长公共前缀

    初始化前缀是首个单词; 遍历每个单词, 和前缀比较; 

    找到开始一样的地方, 记住下标, 更新前缀

15. 三数之和: 返回数组中和是target的三个元素, 不能重复

    递归减规模; 

    两数之和: 排序: 双指针从两头开始, 组成的sum大了low++, 小了就hi--, 相等就加入结果集(注意判重: 相邻元素相等就++指针)

    三数之和: 排序; 对于每一个元素i, 转换成`target=target-nums[i]`的二数之和问题

16. L

17. 电话号码组合: 给数字, 返回可能的号码的字母组合

    ```C++
    vector<string> ans;
    string temp;
    // 错位数组
    string dic[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return ans;
        temp.resize(digits.size());
        dfs(digits, 0);
        return ans;
    }
    // 回溯
    void dfs(string& digits, int k) {
        // 返回条件: 构建的字符长==数字长
        if (k == digits.size()) {
            ans.push_back(temp);
            return;
        }
        // 获得下标
        int t = digits[k] - '0';
        // 遍历下标对应的各个字符
        for (int i = 0; i < dic[t].size(); i++) {
            // 选择: 增加temp长
            temp[k] = dic[t][i];
            // 递归, 处理下一个下边
            dfs(digits, k + 1);
        }
    }
    ```

18. 四数之和:返回数组中和为target的四个数, 不能重复复

    二数之和: 排序: 双指针从两头开始, 组成的sum大了low++, 小了就hi--, 相等就加入结果集(注意判重: 相邻元素相等就++指针)

    三数之和: 排序; 对于每一个元素i, 转换成`target=target-nums[i]`的二数之和问题

19. 删除链表倒数第N个节点: 

    快慢指针, fast到头, slow即是目标节点

20. 有效的括号: 判断括号字符串是否有效

    借助栈先入后出, 遇到左括号, 栈中放入它的右括号; 

    遇到右括号, 在栈顶对比, 如果不一样, 就false; 

    如果能出战完, 就是true

21. 合并两有序链表: 

    串联指针, 遍历两链表, 比较值大小, 串联, 移动小的指针和串联指针

    某个链表为空, 推出循环, 一次性穿起来剩下的那部分

22. 括号生成: 生成N对合法的括号组合

    ```C++
    vector<string> res;
    void helper(string track, int left, int right, int n){
        // 要生成n对括号, 长度就是n*2
        if(track.size() == n*2) { 
            res.push_back(track);
            return;
        }
        // 左括号数量不够
        if(left < n) { 
        	helper(track+"(", left+1, right, n);
        }
        // 右括号不等于左括号，且保证右括号在左前
        if(right < left) { 
        	helper(track+")", left, right+1, n);
        }
    }
    ```

23. 合并K个排序链表: 给一个链表数组, 返回合并后的链表

    ```C++
    // 二分法(归并排序)
    ListNode* merge(vector<ListNode*>& lists, int start, int end){
        // 出口
        if(start == end) return lists[start];
        int mid = (start + end) / 2;
        // 左半部分
        ListNode* l1 = merge(lists, start, mid);
        // 右半部分
        ListNode* l2 = merge(lists, mid+1, end);
        // 合并两个链表
        return merge2(l1, l2);
    }
    ```

24. 两两交换链表节点: 1234=>2143

    ```C++
    while (temp->next != NULL && temp->next->next != NULL){ 
        ListNode* pre = temp->next; 
        ListNode* be = temp->next->next;
        // 1.将后边节点放在前
        temp->next = be; 
        // 2.维系和后续节点的联系
        pre->next = be->next; 
        // 3.将原先在前的节点放在后
        be->next = pre; // 完成交换
        // 4.移动串联指针, 预备下一组交换
        temp = pre; 
    } 
    ```

25. K个一组反转链表: K=2时, 12345 => 21435

    ```C++
    	// 翻转一个子链表，并且返回新的头与尾
        pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
            ListNode* prev = tail->next;
            ListNode* p = head;
            while (prev != tail) {
                ListNode* nex = p->next;
                p->next = prev;
                prev = p;
                p = nex;
            }
            return {tail, head};
        }
    
        ListNode* reverseKGroup(ListNode* head, int k) {
            ListNode* hair = new ListNode(0);
            hair->next = head;
            ListNode* pre = hair;
            // K个一组对链表分组
            while (head) {
                ListNode* tail = pre;
                // 对于每组, 查看剩余部分长度是否大于等于 k
                for (int i = 0; i < k; ++i) {
                    tail = tail->next;
                    if (!tail) {
                        return hair->next;
                    }
                } 
                ListNode* nex = tail->next;
                // 传入每组链表的头和尾, 获取返回后的头和尾
                pair<ListNode*, ListNode*> result = myReverse(head, tail);
                head = result.first;
                tail = result.second;
                // 把子链表重新接回原链表
                pre->next = head;
                tail->next = nex;
                pre = tail;
                head = tail->next;
            }
            return hair->next;
        }
    ```

26. L

27. L

28. L

29. L

30. L

31. L

32. 最长有效括号: 找最长的有效括的字串

    设DP[i]表示以下标为 i 的字符结尾的最长有效子字符串的长度(老套路了)

    ```C++
    // 结尾是左括号肯定不行
    if s[i] == '(' :
        dp[i] = 0
    if s[i] == ')' :
    	// 结尾的两个成型, 就取决于i-2
        if s[i - 1] == '(' :
            dp[i] = dp[i - 2] + 2 
    	// 结尾两个是右括号, 找对应下标是否是左括号
        if s[i - 1] == ')' and s[i - dp[i - 1] - 1] == '(' :
            dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 
    
    ```

33. 搜索旋转排序数组: 

    ```C++
    // 二分法的思想
    while (lo <= hi) {
        mid = lo + (hi - lo) / 2;
        // 找到了
        if (nums[mid] == target) {
        	return mid;
        }
        // 如果nums[mid] > nums[lo], 则左半段有序 
        if (nums[mid] >= nums[lo]) {
            // target在左边的有序段
            if (target >= nums[lo] && target < nums[mid]) {
                // 移动高位指针
                hi = mid - 1;
            } else {
            	lo = mid + 1;
            }
        } 
        // mid之后的右半段有序
        else {
            if (target > nums[mid] && target <= nums[hi]) {
            	lo = mid + 1;
            } else {
            	hi = mid - 1;
            }
        }
    }
    ```

34. 排序数组找目标元素的第一个和最后一个位置

    分别找左边界和右边界

    ```java
    // 找左边区间边界
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            // 中间点分割
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界, 挤出目标索引
                right = mid - 1;
            }
        }
        // 检查出界情况
        if (left >= nums.length || nums[left] != target)
        return -1;
        return left;
    }
    ```

35. L

36. L

37. L

38. L

39. 组合总和: 找数组中和是target的组合

    一定先要排序

    ```C++
    // 回溯
    void DFS(int start, int target) {
        // target减为0
        if (target == 0) {
            res.push_back(path);
            return;
        }
        // 从start遍历每个元素
        for (int i = start; i < candidates.size(); i++) {
            // 剪枝, 遇到比target大的
            if (target - candidates[i] < 0) continue;
            path.push_back(candidates[i]);
            // 递归: target减小规模
            DFS(i, target - candidates[i]);
            path.pop_back();
        }
    }
    ```

40. 组合综合II: 找数组中和是target的组合, 不能重复

    一定先要排序, 剪枝时判断相邻元素是否相等

41. L

42. 接雨水: 数组元素表示柱子高, 求可以接的雨水和

    ```C++
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
        int n = height.size();
        // 双指针
        int left = 0, right = n - 1;
        int ans = 0;
        // l_max是[0,left]中最高的柱子
        int l_max = height[0];
        // r_max是[right,end]中最高的柱子
        int r_max = height[n - 1];
        // 遍历每个柱子, 计算容量
        while (left <= right) {
            l_max = max(l_max, height[left]);
            r_max = max(r_max, height[right]);
            // 容量以短板为准
            if (l_max < r_max) {
                // 累加容量
                ans += l_max - height[left];
                left++; 
            } else {
                ans += r_max - height[right];
                right--;
            }
        }
        return ans;
    }
    ```

43. 字符串相乘: 两个字符串非负整数, 算乘积

    ```C++
    // 双指针遍历两数的每一位, 计算乘积, 叠加到res中
    string multiply(string num1, string num2) {
        int m = num1.size(), n = num2.size();
        // 结果最多为 m + n 位数
        vector<int> res(m + n, 0);
        // 从个位数开始逐位相乘
        for (int i = m - 1; i >= 0; i--)
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1[i]-'0') * (num2[j]-'0');
                // 乘积在 res 对应的索引位置, 至多占用两位
                int p1 = i + j, p2 = i + j + 1;
                // 叠加到 res 上
                int sum = mul + res[p2];
                // 个位
                res[p2] = sum % 10;
                // 进位
                res[p1] += sum / 10;	
            }
        // 结果前缀可能存的 0（未使用的位）
        int i = 0;
        while (i < res.size() && res[i] == 0)
        	i++;
        // 将计算结果转化成字符串
        string str;
        for (; i < res.size(); i++)
            str.push_back('0' + res[i]);
        return str.size() == 0 ? "0" : str;
    }
    ```

44. L

45. L

46. 全排列: 无重复数字的数组, 返回可能的全排列

    ```C++
    void backtrack(vector<int>& track, vector<int>& nums) {
        // 判断
        if (track.size() == nums.size()) {
            res.push_back(track);
            return;
        }
        // 遍历
        for (int i = 0; i < nums.size(); i ++) {
            // 剪枝,取消重复
            // 如果记录的路径中,已经含有了当前元素, 就跳过本次
            if (find(track.begin(), track.end(),nums[i]) != track.end()) continue;
            // 放入选择
            track.push_back(nums[i]);
            // 递归
            backtrack(track, nums);
            // 撤销 选择
            track.pop_back();
        }
    }
    ```

47. 全排列II: 有重复数字的数字, 返回所有可能的全排列

    先排序, 剪枝的时候判断相邻元素是否相等

48. 旋转图像: 原地把矩阵顺势转90°

    ```C++
    // 转置矩阵: 对角线交换, A12-A21
    for(int i = 0; i < len; i ++) {
        for (int j = i; j < len; j ++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    
    // 对于每一行进行左右反转
    for(int i = 0; i < len; i++) {
        // 注意:行长度的奇偶情况
        for(int j = 0; j < len/2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][len-j-1];
            matrix[i][len-j-1] = temp;
        }
    }
    ```

49. L

50. POW快速幂

    ```C++
    double quickMul(double x, long long N) {
        if (N == 0) return 1.0;
        // 递归减N的规模
        double y = quickMul(x, N / 2);
        // 处理N的奇偶
        return N % 2 == 0 ? y * y : y * y * x;
    }
    
    double myPow(double x, int n) {
        long long N = n;
        // 处理指数的正负
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
    ```

51. N皇后: m*n棋盘放置皇后, 使四周不冲突

    关键在于剪枝函数的编写

    ```
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        // 检查列是否有皇后互相冲突
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q')
            return false;
        }
        // 检查右上方是否有皇后互相冲突
        for (int i = row - 1, j = col + 1; 
        	i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q')
                return false;
        }
        // 检查左上方是否有皇后互相冲突
        for (int i = row - 1, j = col - 1;
        	i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
            return false;
        }
        return true;
    }
    ```

52. L

53. 最大子序和: 返回拥有最大和的连续字数组

    ```C++
    // dp[i]表示以nums[i]结尾的子数组的最大和
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    // 维护max, 放dp中的最大值
    int maxs = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        // 两种选择, 择优选取最大的
        dp[i] = max(dp[i - 1] + nums[i], nums[i]);	
        if (maxs < dp[i]) {
        	maxs = dp[i];
        }
    }
    return maxs;
    ```

54. 螺旋矩阵: 顺时针螺旋打印二维矩阵

    ```C++
        // 移动到最右, 更新上边界
        // 移动到最底, 更新右边界...
        vector<int> spiralOrder(vector<vector<int>>& matrix) {
            vector <int> ans;
            if(matrix.empty()) return ans; 
            //赋值上下左右边界
            int u = 0; 
            int d = matrix.size() - 1;
            int l = 0;
            int r = matrix[0].size() - 1;
            while(true) {
                // 向右移动直到最右
                for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); 
                // 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
                if(++ u > d) break; 
                // 向下直到底部
                for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); 
                // 重新设定右边界
                if(-- r < l) break; 
                // 向左
                for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); 
                // 重新设定下边界
                if(-- d < u) break; 
                // 向上
                for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); 
                // 重新设定左边界
                if(++ l > r) break; 
            }
            return ans;
        }
    ```

55. 跳跃游戏: 判断从数组出位置, 能够跳到莫位置

    ```C++
    int flag = nums.size() - 1;
    // 从后往前遍历数组
    for(int i = nums.size() - 1; i >= 0; i --) {
        // 判断前面节点能否到达标志位
        if(nums[i] + i >= flag) {
            // 如果可以，就移动标志位
            flag = i;
        }
    }
    return flag == 0;
    ```

56. L

57. L

58. L

59. L

60. L

61. 旋转链表: 将链表每个节点向右移动 *k* 个位置; 12345=>45123(k=2)

    ```C++
    // 定义快慢指针
    ListNode *slow = head, *fast = head;
    int n = 0;
    // 求链表长
    for(auto p=head;p;p=p->next) n++;
    // 避免k大于链表长的情况
    k %= n;
    int distance = 0;
    while (fast->next) {
        // 快指针先走
        if (distance < k) {
        fast = fast->next;
        distance ++;
        }
        // 同步走
        else {
        fast = fast->next;
        slow = slow->next;
        }
    }
    // 循环结束, 两指针中间的就是需要旋转的
    fast->next = head;
    // 新的头也就是slow指针的后一个节点
    head = slow->next;
    slow->next = NULL;
    // 返回新的头
    return head;
    ```

62. 不同路径: m*n网格, 左上到右下的路径和

    ```C++
    // dp表示到达i+1,j+1的路径和
    vector< vector <int> > dp(m, vector<int> (n));
    // 初始化边界情况
    for (int i = 0; i < m; i ++) dp[i][0] = 1;
    for (int i = 0; i < n; i ++) dp[0][i] = 1;
    // 遍历每个格子
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            // 累加
            dp[i][j] = dp[i - 1][j] + dp[i][j -  1];
        }
    }
    return dp[m-1][n-1];
    ```

63. 不同路径:II: 网格中多了障碍物

    ```java
    // 和上题两处不同
    
    // 注意初始化不同
     for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
     	dp[i][0] = 1;
     }
     for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
     	dp[0][j] = 1;
     }
     ....
    // 注意dp累加前, 先判断
    if (obstacleGrid[i][j] == 0) {
    	dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
    ```

64. 最小路径和: mn网格, 从左上到右下的路径数字总和最小

    ```C++
    int rows = grid.size(), columns = grid[0].size();
    // dp表示i+1,j+1的数字总和
    auto dp = vector<vector<int> > (rows, vector<int>(columns));
    dp[0][0] = grid[0][0];
    // 初始化第一行
    for (int i = 1; i < rows; i++) {
    	dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    // 初始化第一列
    for (int j = 1; j < columns; j++) {
    	dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    // 遍历
    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < columns; j++) {
        	dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[rows - 1][columns - 1];
    ```

65. L

66. L

67. L

68. L

69. X的平方根: 

    ```C++
    // 二分法求平方根
    int l = 0, r = x, ans = -1;
    // 结束点
    while (l <= r) {
        // 分割点
        int mid = l + (r - l) / 2;
        // 小就往大猜
        if ((long long)mid * mid <= x) {
            ans = mid;
            l = mid + 1;
        }
        // 大往小
        else {
        	r = mid - 1;
        }
    }
    return ans;
    ```

70. L

71. L

72. L

73. L

74. L

75. L

76. 最小覆盖字串: 从字符串 S 里面找出：包含 T 所有字符的最小子串

    滑动窗口------------------------------------------

77. 组合: 返回 1 ... *n* 中所有可能的 *k* 个数的组合

    ```C++
    void dfs(int n, int k, int start, vector<int> &path) {
        if (path.size() == k) {
            ans.push_back(path);
            return;
        }
        // 回溯
        for (int i = start; i <= n; i++) {
            path.push_back(i);
            // 递归, 更新索引
            dfs(n,k,i+1,path);
            path.pop_back();
        }
    }
    ```

78. 子集: 给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）

    回溯法, 子集问题不用IF

    ```C++
    void backtrack(vector<int>& nums, int start, vector<int>& track) {
        res.push_back(track);
        // 保证开始索引不越界
        for (int i = start; i < nums.size(); i++) {
            // 做选择
            track.push_back(nums[i]);
            // 回溯, 递归: 更新开始索引
            backtrack(nums, i + 1, track);
            // 撤销选择, 移除track中的最后一个元素
            track.pop_back();
        }
    }
    ```

79. L

80. L

81. L

82. L

83. L

84. L

85. L

86. L

87. L

88. L

89. L

90. L

91. L

92. 翻转链表: 反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转-----------------------------------------------

93. L

94. L

95. L

96. L

97. L

98. L

99. 恢复二叉搜索树: 二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树

    ```
    	TreeNode* preNode = new TreeNode(INT_MIN);
        // 两个目标节点设为全局的
        TreeNode* firstNode = NULL, *secondNode = NULL;
        // 递归函数, 用于找到那两个节点
        void traverse(TreeNode* root) {
            if (root == NULL) return;
            // 中序遍历
            traverse(root->left);
            // 第一次降序
            if (firstNode == NULL && preNode->val > root->val)
                // 取前边的
                firstNode = preNode;
            // 第二次降序
            if (firstNode != NULL && preNode->val > root->val)
                // 取后边的
                secondNode = root;
            // 移动指针
            preNode = root;
            traverse(root->right);
        }
    
        // 在这里执行交换
        void recoverTree(TreeNode* root) {
            traverse(root);
            int tmp = firstNode->val;
            firstNode->val = secondNode->val;
            secondNode->val = tmp;
        }
    ```

100. L

101. L

102. L

103. L

104. 二叉树的最大深度: 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数

     层次遍历, 每遍历完一层, count++

105. 从前序遍历和中序遍历构建二叉树

     ```C++
     TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
         TreeNode* root = helper(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
         return root;
     }
     
     TreeNode* helper(vector<int> pre,int startPre,int endPre,vector<int> vin,int startVin,int endVin) {
         // 边界判断
         if(startPre > endPre || startVin > endVin)
         	return NULL;
         // 1.初始化根节点: 永远是前序遍历的首元素    
         TreeNode* root = new TreeNode(pre[startPre]);
         // 2.遍历中序遍历数组, 区分左右子树    
         for(int i = startVin; i <= endVin; i++)
             if(vin[i] == pre[startPre]) {
                 // 2.1左子树递归创建
                 // 关键在于左右子树的索引范围界定
                 root->left = helper(pre,startPre+1,startPre+i-startVin,vin,startVin,i-1);
                 // 2.2右子树递归创建
                 root->right= helper(pre,i-startVin+startPre+1,endPre,vin,i+1,endVin);
                 break;
         }
     
         return root;
     }
     ```

106. L

107. L

108. L

109. L

110. L

111. L

112. L

113. L

114. 二叉树展开为链表: 前序遍历顺序

     ```C++
     void flatten(TreeNode* root) {
     while (root != nullptr) {
         if (root->left != nullptr) {
                 // 如果左子树不为空, 那么就先找到左子树的最右节点
                 auto most_right = root->left; 
                 // 找最右节点
                 while (most_right->right != nullptr) most_right = most_right->right; 
                 // 然后将跟的右孩子放到最右节点的右子树上
                 most_right->right = root->right;
                 // 这时候跟的右孩子可以释放, 令左孩子放到右孩子上 
                 root->right = root->left;
                 // 将左孩子置为空 
                 root->left = nullptr; 
          }
          // 继续下一个节点
          root = root->right; 
         }
         return;
     }
     ```

115. L

116. L

117. L

118. L

119. L

120. L

121. 买卖股票的最佳时机: 最多只允许完成一笔交易（即买入和卖出一支股票一次）

     ```c++
     int n = prices.length;
     if (n == 0) return 0;
     // dp表示当前i天, 持有(1)或不持有(0)的最大收益
     int[][] dp = new int[n][2];
     for (int i = 0; i < n; i++) {
         // 初始化
         if (i == 0) {
             // 第一天不买
             dp[i][0] = 0;
             // 第一天买了
             dp[i][1] = -prices[i];
             continue;
     	}
         // 当前没有股票 {前一天也没有, 前一天卖了}
         dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
         // 当前有股票 {前一天就有, 前一天买了}
         dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
     }
     // 最大一定是不持有
     return dp[n-1][0];
     ```

122. 买卖股票问题II: 可以尽可能地完成更多的交易（多次买卖一支股票）

     解法同上题; 因为交易次数可以无限大, 所以他对状态的影响忽略

123. 买卖股票问题III: 限制完成两次交易

     ```c++
     if (prices.length == 0) {
     	return 0;
     }
     long[][][] dp = new long[prices.length][3][2];
     dp[0][1][0] = Integer.MIN_VALUE;
     dp[0][1][1] = -prices[0];
     dp[0][2][0] = Integer.MIN_VALUE;
     dp[0][2][1] = Integer.MIN_VALUE;
     for (int i = 1; i < prices.length; i++) {
         dp[i][1][0] =
         Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);
         dp[i][1][1] =
         Math.max(dp[i-1][1][1], -prices[i]);
         dp[i][2][0] =
         Math.max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]);
         dp[i][2][1] =
         Math.max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]);
     }
     int res = (int) Math.max(dp[prices.length - 1][2][0], 	
     	dp[prices.length - 1][1][0]);
     return res < 0 ? 0 : res;
     ```

124. 二叉树中最大路径和: 从树中任意节点出发，达到任意节点的序列

     ```C++
     int dfs(TreeNode* root) {
         // basecase
         if (root == NULL) return 0;
         //计算左边分支最大值, 负数不如0
         int leftMax = max(0, dfs(root->left));
         //计算右边分支最大值
         int rightMax = max(0, dfs(root->right));
         //与历史最大值做比较
         maxs = max(maxs, root->val + leftMax + rightMax);
         //+root计算总和
         return root->val + max(leftMax, rightMax);
     }
     ```

125. 验证回文串:忽略大小写和标点

     两端向中间挤, `while(start < end) `更新指针

126. 单词接龙II

127. 单词接龙

128. L

129. L

130. 被围绕的区域: 找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

131. 分割回文串: 将 *s* 分割成一些子串，使每个子串都是回文串

     ```C++
     	// 回溯
         void backtrack(string s,vector<string>&path,int pre){
             //判断结束条件
             if(pre >= s.size()){     
                 res.push_back(path);
                 return;
             }
             for(int i=pre; i<s.size(); i++){       
                 // 判断是否为回文, 剪枝     
                 if(! checks(s,pre,i)) continue;
                 // 注意: substr(pos,n)
                 path.push_back(s.substr(pre,i+1-pre));
                 backtrack(s,path,i+1);
                 path.pop_back();    //还原
             }
         }
     
         // 判断是否是回文串
         bool checks(string s, int le, int ri) {
             // 严格小于即可
             while (le < ri) {
                 if (s[le] != s[ri]) {
                     return false;
                 }
                 le++;
                 ri--;
             }
             return true;
         }
     ```

132. L

133. ;

134. 加油站: 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

     你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

     如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

     ```c++
     int n = gas.size();
     // 邮箱总量
     int total_tank = 0;
     // 当前量
     int curr_tank = 0;
     // 起始加油站
     int starting_station = 0;
     // 遍历每一个油站
     for (int i = 0; i < n; ++i) {
         // 总量 = 原总量 + 油站有的 - 到i消耗的
         total_tank += gas[i] - cost[i];
         // 当前量 = 原当前 + 油站有的 - 到i消耗的
         curr_tank += gas[i] - cost[i];
         // 到不了: 当前量<0
         if (curr_tank < 0) {
             // 就将下一个作为起始加油站
             starting_station = i + 1;
             // 当前量置为0
             curr_tank = 0;
         }
     }
     // 总量不空就能到
     return total_tank >= 0 ? starting_station : -1;
     ```

135. 分发糖果: 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

     你需要按照以下要求，帮助老师给这些孩子分发糖果：

     每个孩子至少分配到 1 个糖果。
     相邻的孩子中，评分高的孩子必须获得更多的糖果。
     那么这样下来，老师至少需要准备多少颗糖果呢？

     ```C++
     int candy(vector<int>& ratings) {
         int n = ratings.size();
         // 两次遍历, 记录两次值, 取最大的累加
         vector<int> left(n,1);
         vector<int> right(n,1);
         // 从前往后
         for(int i = 1; i < n; i++)
             // 如果当前的分数大于前一个, 就把当前的加一
             if(ratings[i] > ratings[i - 1]) 
             	left[i] = left[i - 1] + 1;
         // 记录最后一个孩子的糖果数
         int count = left[n - 1];
         // 从后往前, 从倒数第二个孩子开始
         for(int i = n - 2; i >= 0; i--) {
             // 如果当前的分数大于后一个, 就把当前的加一
             if(ratings[i] > ratings[i + 1]) right[i] = right[i + 1] + 1;
             // 取最大的累加
             count += max(left[i], right[i]);
         }
         return count;
     }
     ```

136. 只出现一次的数字: 其他都出现两次

     ```C++
     for (int i = 1; i < nums.size(); i++) {
         // 相同为0, 不同为1
         ans = ans ^ nums[i];
     }
     ```

137. 只出现一次的数字: 其他都出现三次

     ```C++
     // 遍历int的32位
     // 相同数字的同一位0或1出现次数一定是3的整数倍
     for(int i = 0; i < 32; ++i){
         int sum = 0;
         // 遍历每个数字的每一位
         for(int j = 0;j < nums.size();++j){
             // 统计每一位出现的次数
             sum += (nums[j] >> i) & 1;
         }
         // 求余得出目标数字在该位上的值
         // 进而构求出原数字
         res ^= (sum % 3) << i;
     }
     ```

138. L

139. L

140. L

141. 环形链表: 

     快慢指针, 构建速度差, 有环必定相遇

142. L

143. L

144. L

145. L

146. LRU缓存机制: 有容量, 最长时间没有访问的踢出去
    带有key~value的双向链表(双向是为了方便定位到尾节点, 也就是最久没访问的那个节点)

147. L

148. 排序链表: 
    每次双指针找到中间点断开, 递归地拆分左右两边, 直到子链表中只有一个节点(有序)
    合并两个有序链表

149. L

150. L

151. L

152. L

153. L

154. L

155. L

156. L

157. L

158. L

159. L

160. 相交链表: 找到两个单链表相交的起始节点
    ```C++
    if (headA == NULL || headB == NULL)
            return (ListNode*) NULL;
    ListNode* pa = headA;
    ListNode* pb = headB;
    // 当pa==pb时, 就是那第一个焦点
    while (pa != pb) {
        // pa跑完了在pb跑
        if (pa!=NULL) pa = pa->next;
        else pa = headB;
        // pb跑完了在pa跑
        if (pb!=NULL) pb = pb->next;
        else pb = headA;
    }
    // 相遇了就返回
    return pa;
    ```

161. L

191. 位1的个数: 一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）
    ```C++
    int count = 0;
    while(n > 0) {
        // 每次减少一位
        n &= (n - 1);
        count ++;
    }
    return count;
    ```
198. 打家劫舍: 不能投连续的房子, 求最大利润
    ```C++
    int N = nums.size();
    // dp表示当前i个房子能获取的最多
    vector<int> dp(N+1, 0);
    // 无意义
    dp[0] = 0;
    // 当前一个放子获取nums[0]
    dp[1] = nums[0];
    for (int k = 2; k <= N; k++) {
        // 偷前一个这个不偷 || 偷前前一个, 和这个
        dp[k] = max(dp[k-1], nums[k-1] + dp[k-2]);
    }
    return dp[N];
    ```

199. 二叉树的右视图: 想象自己从二叉树右侧看到的节点
    层次遍历: 将当前层的最后一个节点放入结果(`if size-1 == i`)

200. 岛屿数量: 网格中的岛屿数量
    DFS深度遍历每个 `grid[i][j]==1`的节点
    相邻节点: 上下左右
    basecase: 到达边界; 不是1则直接返回

206. 反转链表: 1234=>4321
    ```C++
    while(head) {
        // 备份当前的下一个节点
        ListNode* tmp = head->next;
        // 使当前节点链接新头newHead
        head->next = newHead;
        // 把当前节点放到新头中
        newHead = head;
        // 移动当前节点
        head = tmp;
    }
    ```

207. 课程表: 判断有向图中是否有环?
    把所有入度为0的阶段放进队列, 因为不会冲突
    遍历队列, 找当前节点的相邻节点, 如果相邻节点的入度-1==0, 入队
    遍历完成, 判断课程总数是否减到0

208. 实现前缀树: 
    插入: 从根节点的子节点开始和word的字符匹配, 直到树中没有匹配的, 然后开辟新节点, 放置剩下的字符
    搜索: 从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回false，如果匹配到了最后一个字符，那我们只需判断node->isEnd即可
    前缀匹配: 和 search 操作类似，只是不需要判断最后一个字符结点的isEnd，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的

213. 打家劫舍II: 房屋围成一圈, 相邻的不能投
    房屋1和最后一间房子相邻, 不能同时被偷, 那么, 就有三种情况:
    1. 房屋1被偷, 最后一个没有被偷
    2. 最后一个被偷, 房屋1没有被偷
    3. 都没有被偷
    这三种情况将整个数组拆分成三个部分数组, 区间分别是[0, size-2], [1, size-1], [1, size-2], 分别求出它们的最大值(对于每一部分数组, 还是题目一的思路)

214. 最短回文串: 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串


225. 队列实现栈: 
    关键在于, 向队列左端放入元素之后, 要把右端的都移除放到左端, 保证栈顶(队列右端)是最近的

232. 栈实现队列: in栈和out栈
    总体思路就是, 压入的时候把元素放到in栈; 查询的时候操作out栈(从in栈依次放入的)
    插入: 直接压入in栈
    移除: 如果outStack中没有元素，就先把inStack中的元素依次弹出压入outStack; 如果outStack中已经有元素了,就直接获取outStack的栈顶元素
    获取栈顶: 如果outStack中没有元素，就先把inStack中的元素依次弹出压入outStack; outStack中已经有元素了,就直接获取outStack的栈顶元素

234. 回文链表: 反转前半部分链表, 然后和后半部分比较, 注意奇偶问题
    ```C++
    // 遍历的时候反转前半部分
    while(fast && fast->next){
        p = slow;
        slow = slow->next;    //快慢遍历
        fast = fast->next->next;
        //翻转
        p->next = pre;  
        pre = p;
    }
    //奇数个节点时跳过中间节点  
    if(fast)  
        slow = slow->next;
    // 前半部分和后半部分比较
    while(p){       
        if(p->val != slow->val)
            return 0;
        p = p->next;
        slow = slow->next;
    }
    ```

236. 二叉树的最近公共祖先: 
    两种情况: pq在祖先的两侧, 那么当前节点就是所求; pq在一侧, 那么靠上边的那个就是所求
    ```C++
    // basecase 
    if (!root || root == p || root == q) return root;
    // 找左半部分 
    TreeNode *left = lowestCommonAncestor(root->left, p, q);
    // 找右半部分
    TreeNode *right = lowestCommonAncestor(root->right, p, q);
    // p q在两侧, 当前就是所求
    if (left && right) return root;
    // p q在一侧, 上边的那个是所求
    return left ? left : right;
    ```

260. 只出现一次的数字III: 两个元素出现一次, 其余都出现两次
    思路: 把这两个元素分到两个数组中, 然后分别异或求得
        如何分?  因为a b两个数字不等, 所以a^b结果必至少有一位是1(因为0^1=, ab必至少有一位不同)
            找到a b异或结果中为1的任意一位, 通过该为位对数字分组
    ```C++
    // 异或结果
    int s = 0;
    for (int num : nums) {
        s ^= num;
    }
	// k是结果中为1的某一位
    int k = s & (-s);
    vector<int> rs(2,0);
    // 遍历数字,通过k分组
    for(int num : nums){
        if(num & k){
            //第二组
            rs[0] ^= num;
        }else{
            //第一组
            rs[1] ^= num;
        }
    }
    return rs;
    ```

292. NIM游戏: 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手
    关键在于: 总是给对手留下4块石头，那么对手一定会输;
        所以如果自己先手, 而石头数又是4的整数倍的话, 就一定会输

300. 最长上升子序列: 无序的整数数组，找到其中最长上升子序列的长度
    ```C++
    // 对于当前元素i
    for (int i = 0; i < n; i ++) {
        // 找到前遍序列中比元素i小的数
        for (int j = 0; j < i;j ++) {
            if (nums[j] < nums[i])
                // 要么续住之前的, 要么自己新开一个序列
                dp[i] = max(dp[i], dp[j]+1);
        }
    }
    ```

315. 计算右侧小于当前元素的个数:  counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量

322. 零钱兑换: 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数

337. 打家劫舍III: 这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警
    ```C++
    Map<TreeNode, Integer> memo = new HashMap<>();
    // 递归
    public int rob(TreeNode root) {
        if (root == null) return 0;
        // 如果备忘录中有, 直接返回
        if (memo.containsKey(root)) 
            return memo.get(root);
        // 抢，然后去下下家
        int do_it = root.val
            + (root.left == null ? 
                0 : rob(root.left.left) + rob(root.left.right))
            + (root.right == null ? 
                0 : rob(root.right.left) + rob(root.right.right));
        // 不抢，然后去下家
        int not_do = rob(root.left) + rob(root.right);
        // 两种选择中取最大的
        int res = Math.max(do_it, not_do);
        memo.put(root, res);
        return res;
    }
    ```

372. 超级次方: 计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出
    ```C++
    int base = 1337;
    // 计算 a 的 k 次方然后与 base 求模的结果
    int mypow(int a, int k) {
        // 对因子求模
        a %= base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            // 这里有乘法，是潜在的溢出点
            res *= a;
            // 对乘法结果求模
            res %= base;
        }
        return res;
    }
    // 递归
    int superPow(int a, vector<int>& b) {
        if (b.empty()) return 1;
        // 每次从数组中取末位
        int last = b.back();
        b.pop_back();
        // 计算末位部分
        int part1 = mypow(a, last);
        // 递归计算剩余部分
        int part2 = mypow(superPow(a, b), 10);
        // 两部分相乘得结果; 每次乘法都要求模
        return (part1 * part2) % base;
    }
    ```

376. 摆动序列: 连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列
        给定一个整数序列，返回作为摆动序列的最长子序列的长度
    ```C++
    // 特判
    if(nums.size()<2) return nums.size();
    // 状态机状态
    const int begin=0;
    const int up=1;
    const int down=2;
    // 初始状态
    int state = begin;
    int length = 1;
    // 状态的切换, 也就意味着length的重新开始
    for(int i = 1; i < nums.size(); i ++){
        switch(state){
            case begin:
                // 初始状态, 定义增降
                if(nums[i-1] < nums[i]){
                    state = up;
                    length ++;
                }
                else if(nums[i-1] > nums[i]){
                    state = down;
                    length ++;
                }
                break;
            case up:
                // 增 => 降
                if(nums[i-1] > nums[i]){
                    state = down;
                    length ++;
                }
                break;
            case down:
                // 降 => 增
                if(nums[i-1] < nums[i]){
                    state = up;
                    length ++;
                }
                break;
        }
    }
    return length;
    ```
402. 移除掉K位数字: 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小

409. 最长回文串: 给定一个包含大写字母和小写字母的字符串 找到通过这些字母构造成的最长的回文串
    ```C++
    // 缓存数组, 记录次数
    vector<int> arr(128);
    // 记录每种字符出现的次数
    for(char c : s) {
        arr[c]++;
    }
    int count = 0;
    // 出现偶数次, 一定可以拼成 
    for (int i = 0; i < arr.size(); i ++) {
        count += (arr[i] % 2);
    }
    // 都出现偶数次, 结果就是有多少种字符 
    // 出现有奇数次的, 就是偶数次的+1(奇数次的字符智能有一个放在中间)
    return count == 0 ? s.length() : (s.length() - count + 1);
    ```

416. 分割等和子集: 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等
    ```C++
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.size();
    // 容量是sum/2的背包
    sum = sum / 2;
    // 当前i个物品, 背包容量是sum的情况下, 能不能装入
    vector<vector<bool>> 
        dp(n + 1, vector<bool>(sum + 1, false));
    // base case
    for (int i = 0; i <= n; i++)
        dp[i][0] = true;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
                // 背包容量不足，不能装入第 i 个物品
                // 继承上一个状态
                dp[i][j] = dp[i - 1][j]; 
            } else {
                // 能装的下: 选择: 装入或不装入背包
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j-nums[i-1]];
            }
        }
    }
    return dp[n][sum];
    ```

438. 找到字符串中所有字母异位词

455. 分发饼干: 
    ```C++
    // 贪心
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // 排序
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        // 记录索引
        int res = 0, stry = 0;
        // 把饼干值大的优先发给胃口大的
        while (res < g.size() && stry < s.size()) {
            // 能满足, 就继续下一个饼干
            if (g[res] <= s[stry])
                res ++;
            // 不管能不能满足, 都继续下一个孩子
            stry ++;
        }
        return res;
    }
    ```